# The twelve factor app

简介
如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS）。12-Factor 为构建如下的 SaaS 应用提供了方法论：

* 使用标准化流程自动配置，从而使新的开发者花费最少的学习成本加入这个项目。
* 和操作系统之间尽可能的划清界限，在各个系统中提供最大的可移植性。
* 适合部署在现代的云计算平台，从而在服务器和系统管理方面节省资源。
* 将开发环境和生产环境的差异降至最低，并使用持续交付实施敏捷开发。
* 可以在工具、架构和开发流程不发生明显变化的前提下实现扩展。


---

## I.基准代码

一份基准代码（Codebase），多份部署（deploy） (Git as the code repository)
基准代码和应用之间总是保持一一对应的关系：
![codebase-deploys][image-1]
* 一旦有多个基准代码，就不能称为一个应用，而是一个分布式系统。分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用 12-Factor 进行开发。
* 多个应用共享一份基准代码是有悖于 12-Factor 原则的。解决方案是将共享的代码拆分为独立的类库，然后使用 依赖管理 策略去加载它们。
* 所有部署的基准代码相同，但每份部署可以使用其不同的版本。比如，开发人员可能有一些提交还没有同步至预发布环境；预发布环境也有一些提交没有同步至生产环境。但它们都共享一份基准代码，我们就认为它们只是相同应用的不同部署而已。

---

## II.依赖
显式声明依赖关系（ dependency ）

* 12-Factor规则下的应用程序不会隐式依赖系统级的类库。 它一定通过依赖清单 ，确切地声明所有依赖项。在运行过程中通过 依赖隔离 工具来确保程序不会调用系统中存在但清单中未声明的依赖项。


---

### III.配置服务

在环境中存储配置

* 代码和配置严格分离
* 一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。
* 这里定义的“配置”并不包括应用的内部配置
* 另外一个解决方法是使用配置文件，但不把它们纳入版本控制系统
* 12-Factor推荐将应用的配置存储于环境变量中(env vars, env)。环境变量可以非常方便地在不同的部署间做修改

---


## IV.后端服务

把后端服务(backing services)当作附加资源

* 后端服务是指程序运行所需要的通过网络调用的各种服务，如数据库（MySQL，CouchDB），消息/队列系统（RabbitMQ，Beanstalkd），SMTP 邮件发送服务（Postfix），以及缓存系统（Memcached）。
* 应用程序有可能使用了第三方发布和管理的服务。

![resource.png][image-2]

* 部署可以按需加载或卸载资源。例如，如果应用的数据库服务由于硬件问题出现异常，管理员可以从最近的备份中恢复一个数据库，卸载当前的数据库，然后加载新的数据库 – 整个过程都不需要修改代码。

---

## V.构建，发布，运行
严格分离构建和运行

基准代码 转化为一份部署(非开发环境)需要以下三个阶段：
1. 构建阶段，是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包 依赖项，编译成二进制文件和资源文件。
2. 发布阶段，会将构建的结果和当前部署所需配置相结合，并能够立刻在运行环境中投入使用。
3. 运行阶段 （或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序 进程。

12-facfor 应用严格区分构建，发布，运行这三个步骤。 举例来说，直接修改处于运行状态的代码是非常不可取的做法，因为这些修改很难再同步回构建步骤。
![release][image-3]

---

## V.构建，发布，运行

* 部署工具通常都提供了发布管理工具，最引人注目的功能是退回至较旧的发布版本。比如， Capistrano 将所有发布版本都存储在一个叫 releases 的子目录中，当前的在线版本只需映射至对应的目录即可。该工具的 rollback 命令可以很容易地实现回退版本的功能。
* 每一个发布版本必须对应一个唯一的发布 ID，例如可以使用发布时的时间戳（2011-04-06-20:32:17），亦或是一个增长的数字（v100）。发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。
* 新的代码在部署之前，需要开发人员触发构建操作。但是，运行阶段不一定需要人为触发，而是可以自动进行。
  如服务器重启，或是进程管理器重启了一个崩溃的进程。因此，运行阶段应该保持尽可能少的模块，这样假设半夜发生系统故障而开发人员又捉襟见肘也不会引起太大问题。构建阶段是可以相对复杂一些的，因为错误信息能够立刻展示在开发人员面前，从而得到妥善处理。

---

## VI.进程
以一个或多个无状态进程运行应用

12-Factor 应用的进程必须无状态且无共享。任何需要持久化的数据都要存储在后端服务内，比如数据库。

粘性session是 12-Factor 极力反对的。Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。

---

## VII.端口服务
通过端口绑定(Port binding)来提供服务

12-Factor 应用完全自我加载而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用通过端口绑定来提供服务，并监听发送至该端口的请求。

---

## VIII.并发
通过进程模型进行扩展
* 在 12-actor 应用中，进程是一等公民。例如，HTTP 请求可以交给 web 进程来处理，而常驻的后台工作则交由 worker 进程负责。
![process-types][image-4]
* 这并不包括个别较为特殊的进程，例如通过虚拟机的线程处理并发的内部运算，或是使用诸如 EventMachine, Twisted, Node.js 的异步/事件触发模型。但一台独立的虚拟机的扩展有瓶颈（垂直扩展），所以应用程序必须可以在多台物理机器间跨进程工作。
* 12-Factor应用的进程不需要守护进程或是写入PID文件。相反的，应该借助操作系统的进程管理器(例如 Upstart ，分布式的进程管理云平台，或是类似 Foreman 的工具)，来管理输出流 ，响应崩溃的进程，以及处理用户触发的重启和关闭超级进程的请求。

---
## IX.易处理
快速启动和优雅终止可最大化健壮性
12-Factor应用的进程是易处理（disposable）的，意思是说它们可以瞬间开启或停止。 这有利于快速、弹性的伸缩应用，迅速部署变化的代码或配置 ，稳健的部署应用。
* 进程应当追求最小启动时间 。 理想状态下，进程从敲下命令到真正启动并等待请求的时间应该只需很短的时间。更少的启动时间提供了更敏捷的发布 以及扩展过程，此外还增加了健壮性，因为进程管理器可以在授权情形下容易的将进程搬到新的物理机器上。
* 进程一旦接收终止信号（SIGTERM）就会优雅的终止。
　　就网络进程而言，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出。此类型的进程所隐含的要求是HTTP请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。
* 对于worker进程来说，优雅终止是指将当前任务退回队列。例如，RabbitMQ中，worker 可以发送一个NACK信号。 Beanstalkd中，任务终止并退回队列会在worker断开时自动触发。有锁机制的系统诸如 Delayed Job 则需要确定释放了系统资源。此类型的进程所隐含的要求是，任务都应该可重复执行， 这主要由将结果包装进事务或是使重复操作幂等来实现。
* 进程还应当在面对突然死亡时保持健壮，例如底层硬件故障。虽然这种情况比起优雅终止来说少之又少，但终究有可能发生。一种推荐的方式是使用一个健壮的后端队列，例如 Beanstalkd ，它可以在客户端断开或超时后自动退回任务。无论如何，12-Factor 应用都应该可以设计能够应对意外的、不优雅的终结。Crash-only design 将这种概念转化为 合乎逻辑的理论。

---

## X.开发环境与线上环境等价
尽可能的保持开发，预发布，线上环境相同
* 12-Factor 应用的开发人员应该反对在不同环境间使用不同的后端服务 ，即使适配器已经可以几乎消除使用上的差异。
与此同时，轻量的本地服务也不像以前那样引人注目。借助于Homebrew，apt-get等现代的打包系统，诸如Memcached、PostgreSQL、RabbitMQ 等后端服务的安装与运行也并不复杂。此外，使用类似 Chef 和 Puppet 的声明式配置工具，结合像 Vagrant 这样轻量的虚拟环境就可以使得开发人员的本地环境与线上环境无限接近。与同步环境和持续部署所带来的益处相比，安装这些系统显然是值得的。

* 不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。

---

## XI.日志
把日志当作事件流
* 12-factor应用本身从不考虑存储自己的输出流。 不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出（stdout）事件流。
* 开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。
* 在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。类似 Logplex 和 Fluent 的开源工具可以达到这个目的。
* 这些事件流可以输出至文件，或者在终端实时观察。最重要的，输出流可以发送到 Splunk这样的日志索引及分析系统，或Hadoop/Hive这样的通用数据存储统。这些系统为查看应用的历史活动提供了强大而灵活的功能，包括：
1. 找出过去一段时间特殊的事件。
2. 图形化一个大规模的趋势，比如每分钟的请求量。
3. 根据用户定义的条件实时触发警报，比如每分钟的报错超过某个警戒线。

---

## XII.管理进程

12-factor 尤其青睐那些提供了 REPL shell 的语言，因为那会让运行一次性脚本变得简单。在本地部署中，开发人员直接在命令行使用 shell 命令调用一次性管理进程。在线上部署中，开发人员依旧可以使用ssh或是运行环境提供的其他机制来运行这样的进程。

---

# Thank you !





[image-1]:	./imgs/codebase-deploys.png
[image-2]:	./imgs/attached-resources.png "backend service as a resource"
[image-3]:	./imgs/release.png
[image-4]:	./imgs/process-types.png